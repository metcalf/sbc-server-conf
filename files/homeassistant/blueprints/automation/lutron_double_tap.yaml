blueprint:
  name: "Lutron Double Tap"
  description: >
    Implements a double tap event from Lutron RA3 keypads. Since RA3 doesn't emit double-tap events
    for "Scene" and "Zone" buttons, this blueprint simulates the behavior by detecting rapid button
    presses and can restore lights to either first press state or preserve second press state.

  domain: automation

  input:
    button_entities:
      name: "Buttons"
      description: "The Lutron keypad button entity(s) to monitor"
      selector:
        entity:
          filter:
            domain:
              - button
          multiple: true

    light_entities:
      name: "Associated Lights"
      description: "Lights controlled by this button (will be preserved on double-tap)"
      selector:
        entity:
          filter:
            domain: light
          multiple: true

    event_name:
      name: "Double Tap Event Name"
      description: "Name of the event to fire on double-tap (e.g., 'lutron_double_tap')"
      default: "lutron_double_tap"
      selector:
        text:

    double_tap_behavior:
      name: "Double Tap Light Behavior"
      description: "What to do with lights on double tap detection"
      default: "preserve_second_press"
      selector:
        select:
          options:
            - label: "Preserve Second Press State (Current Behavior)"
              value: "preserve_second_press"
            - label: "Restore to First Press State"
              value: "restore_first_press"

    transition_time:
      name: "Light Transition Time"
      description: "Transition time for light state changes (seconds). 0 = instant."
      default: 0.5
      selector:
        number:
          min: 0
          max: 10.0
          step: 0.1
          unit_of_measurement: "s"

    double_tap_window:
      name: "Double Tap Time Window"
      description: "Maximum time between presses to consider it a double-tap (seconds)"
      default: 1.0
      selector:
        number:
          min: 0.2
          max: 3.0
          step: 0.1
          unit_of_measurement: "s"

    minimum_gap:
      name: "Minimum Gap Between Presses"
      description: "Minimum time between presses to avoid rapid-fire triggers (seconds)"
      default: 0.05
      selector:
        number:
          min: 0.01
          max: 0.2
          step: 0.01
          unit_of_measurement: "s"

    state_capture_helper:
      name: "State Storage Helper (Optional)"
      description: "Input text helper to store light states for first press restoration. Create an input_text helper if using 'restore_first_press' option."
      default: ""
      selector:
        entity:
          filter:
            domain: input_text

    enable_logging:
      name: "Enable Detailed Logging"
      description: "Log single taps and double-tap prevention events"
      default: true
      selector:
        boolean:

# The automation template
trigger:
  - platform: state
    entity_id: !input button_entities

variables:
  current_timestamp: "{{ as_timestamp(now()) }}"
  last_press_time: >
    {% set last_time = state_attr(this.entity_id, 'last_triggered') %}
    {% if last_time == None %}
      0
    {% else %}
      {{ as_timestamp(last_time) }}
    {% endif %}
  time_diff: "{{ current_timestamp - last_press_time }}"
  button_entities: !input button_entities
  transition_time: !input transition_time
  double_tap_window: !input double_tap_window
  minimum_gap: !input minimum_gap
  light_entities: !input light_entities
  enable_logging: !input enable_logging
  double_tap_behavior: !input double_tap_behavior
  state_capture_helper: !input state_capture_helper

  # Helper function to capture current light states
  current_light_states: >
    {% set states_dict = {} %}
    {% for light in light_entities %}
      {% set light_state = states(light) %}
      {% set states_dict = dict(states_dict, **{light: {
        'state': light_state,
        'attributes': {
          'brightness': state_attr(light, 'brightness'),
        }
      }}) %}
    {% endfor %}
    {{ states_dict }}

  # Get stored states from helper (for first press restoration)
  stored_light_states: >
    {% if state_capture_helper != '' %}
      {% set stored_data = states(state_capture_helper) %}
      {% if stored_data != 'unknown' and stored_data != '' %}
        {{ stored_data | from_json }}
      {% else %}
        {}
      {% endif %}
    {% else %}
      {}
    {% endif %}

action:
  - choose:
      # Double tap detected
      - conditions:
          - condition: template
            value_template: >
              {{ time_diff < double_tap_window and time_diff > minimum_gap }}
        sequence:
          - if:
              - condition: template
                value_template: "{{ enable_logging }}"
            then:
              - service: logbook.log
                data:
                  name: "Lutron double tap detected"
                  message: >
                    Lutron double tap detected {{ trigger.entity_id }}
                    ({{ time_diff | round(2) }}s gap, behavior: {{ double_tap_behavior }})

          # Fire the custom event for other automations to use
          - event: "{{ event_name }}"
            event_data:
              button_entity: "{{ trigger.entity_id }}"
              time_since_last_press: "{{ time_diff | round(3) }}"
              timestamp: "{{ current_timestamp }}"
              light_entities: "{{ light_entities }}"
              behavior: "{{ double_tap_behavior }}"

          # Determine which states to restore to
          - variables:
              target_states: >
                {% if double_tap_behavior == 'restore_first_press' and stored_light_states != {} %}
                  {{ stored_light_states }}
                {% else %}
                  {{ current_light_states }}
                {% endif %}
              behavior_name: >
                {% if double_tap_behavior == 'restore_first_press' and stored_light_states != {} %}
                  first press
                {% else %}
                  second press
                {% endif %}

          - if:
              - condition: template
                value_template: "{{ enable_logging }}"
            then:
              - service: logbook.log
                data:
                  name: "Restoring light states"
                  message: "Restoring lights to {{ behavior_name }} state for {{ trigger.entity_id }}"

          # Single restoration sequence that works with any states dictionary
          - repeat:
              for_each: "{{ light_entities }}"
              sequence:
                - variables:
                    light_entity: "{{ repeat.item }}"
                    target_light_state: "{{ target_states.get(light_entity, {}) }}"

                - if:
                    - condition: template
                      value_template: "{{ target_light_state != {} }}"
                  then:
                    - choose:
                        # Restore to 'on' state with all attributes
                        - conditions:
                            - condition: template
                              value_template: "{{ target_light_state.get('state') == 'on' }}"
                          sequence:
                            - service: light.turn_on
                              target:
                                entity_id: "{{ light_entity }}"
                              data: >
                                {% set data = {} %}
                                {% set attrs = target_light_state.get('attributes', {}) %}
                                {% for attr_name, attr_value in attrs.items() %}
                                  {% if attr_value is not none %}
                                    {% set data = dict(data, **{attr_name: attr_value}) %}
                                  {% endif %}
                                {% endfor %}
                                {% if transition_time > 0 %}
                                  {% set data = dict(data, transition=transition_time) %}
                                {% endif %}
                                {{ data }}

                        # Restore to 'off' state
                        - conditions:
                            - condition: template
                              value_template: "{{ target_light_state.get('state') == 'off' }}"
                          sequence:
                            - service: light.turn_off
                              target:
                                entity_id: "{{ light_entity }}"
                              data: >
                                {% set data = {} %}
                                {% if transition_time > 0 %}
                                  {% set data = dict(data, transition=transition_time) %}
                                {% endif %}
                                {{ data }}

    # Single tap - capture current light states for potential restoration
    default:
      - if:
          - condition: template
            value_template: "{{ state_capture_helper != '' }}"
        then:
          - service: input_text.set_value
            target:
              entity_id: "{{ state_capture_helper }}"
            data:
              value: "{{ current_light_states | to_json }}"

      - if:
          - condition: template
            value_template: "{{ enable_logging }}"
        then:
          - service: logbook.log
            data:
              name: "Single Tap"
              message: "Single tap detected for {{ trigger.entity_id }}"
