blueprint:
  name: "Lutron Double Tap"
  description: >
    Implements a double tap event from Lutron RA3 keypads. Since RA3 doesn't emit double-tap events
    for "Scene" and "Zone" buttons, this blueprint simulates the behavior by detecting rapid button
    presses and can restore lights to either first press state or preserve second press state.

    Requires one input_text helper to store timing and brightness data.

  domain: automation

  input:
    button_entities:
      name: "Buttons"
      description: "The Lutron keypad button entity(s) to monitor"
      default: []
      selector:
        entity:
          filter:
            domain:
              - button
          multiple: true

    extra_triggers:
      selector:
        trigger:

    light_entities:
      name: "Associated Lights"
      description: "Lights controlled by this button (will be preserved on double-tap)"
      default: []
      selector:
        entity:
          filter:
            domain: light
          multiple: true

    triggered_action:
      name: Triggered actions
      description: Actions that should be executed on double-tap
      default: []
      selector:
        action: {}

    event_name:
      name: "Double Tap Event Name"
      description: "Name of the event to fire on double-tap"
      default: ""
      selector:
        text:

    double_tap_window:
      name: "Double Tap Time Window"
      description: "Maximum time between presses to consider it a double-tap (seconds)"
      default: 0.5
      selector:
        number:
          min: 0.2
          max: 3.0
          step: 0.1
          unit_of_measurement: "s"

    minimum_gap:
      name: "Minimum Gap Between Presses"
      description: "Minimum time between presses to avoid rapid-fire triggers (seconds)"
      default: 0.05
      selector:
        number:
          min: 0.01
          max: 0.2
          step: 0.01
          unit_of_measurement: "s"

    storage_helper:
      name: "Storage Helper"
      description: "Input text helper to store timing and brightness data (required). Set max length to 255 characters."
      selector:
        entity:
          filter:
            domain: input_text

    enable_logging:
      name: "Enable Detailed Logging"
      description: "Log single taps and double-tap prevention events"
      default: true
      selector:
        boolean:

# The automation template
triggers:
  - trigger: event
    id: "default_button_trigger"
    event_type: lutron_caseta_button_event
    event_data:
      action: press
      type: SunnataHybridKeypad
  - triggers: !input extra_triggers

variables:
  current_timestamp: "{{ as_timestamp(trigger.event.time_fired) }}"
  button_entities: !input button_entities
  event_name: !input event_name
  double_tap_window: !input double_tap_window
  minimum_gap: !input minimum_gap
  light_entities: !input light_entities
  enable_logging: !input enable_logging
  storage_helper: !input storage_helper

  # Construct the button name from event data to match with entities
  event_button_name: >
    {{ trigger.event.data.area_name ~ " " ~ trigger.event.data.device_name ~ " " ~ trigger.event.data.button_type }}

  # Find the matching button entity
  matching_button_entity: >
    {% set button_event_name = trigger.event.data.area_name ~ " " ~ trigger.event.data.device_name ~ " " ~ trigger.event.data.button_type %}
    {% for button in button_entities %}
      {% if state_attr(button, 'friendly_name') == button_event_name %}
        {{ button }}
        {% break %}
      {% endif %}
    {% endfor %}

  # Get stored data
  stored_data: >
    {% set stored = states(storage_helper) %}
    {% if stored != 'unknown' and stored != '' %}
      {{ stored | from_json }}
    {% else %}
      {"last_press": 0, "lights": {}}
    {% endif %}

  # Calculate time since last press
  last_press_time: "{{ stored_data.get('last_press', 0) }}"

  time_diff: "{{ current_timestamp - last_press_time }}"

  # Helper function to capture current light brightness
  current_light_brightness: >
    {% set ns = namespace(brightness_dict={}) %}
    {% for light in light_entities %}
      {% set light_state = states(light) %}
      {% if light_state == 'on' %}
        {% set brightness = state_attr(light, 'brightness') or 255 %}
        {% set ns.brightness_dict = ns.brightness_dict | combine({light: brightness}) %}
      {% elif light_state == 'off' %}
        {% set ns.brightness_dict = ns.brightness_dict | combine({light: 0}) %}
      {% endif %}
    {% endfor %}
    {{ ns.brightness_dict }}

  # Get stored light brightness (for first press restoration)
  stored_light_brightness: "{{ stored_data.get('lights', {}) }}"

action:
  # Only proceed if we found a matching button entity
  - condition: template
    value_template: "{{ trigger.id != 'default_button_trigger' or matching_button_entity != '' }}"

  - if:
      - condition: template
        value_template: >
          {{ time_diff < double_tap_window and time_diff > minimum_gap }}
    # Double tap detected
    then:
      - if:
          - condition: template
            value_template: "{{ enable_logging }}"
        then:
          - service: logbook.log
            data:
              name: "Lutron double tap"
              message: "Lutron double tap detected {{ matching_button_entity }}. Setting lights to original brightness for {{ matching_button_entity }}"

      # Fire the custom event for other automations to use
      - if:
          - condition: template
            value_template: "{{ event_name != '' }}"
        then:
          - event: "{{ event_name }}"
            event_data:
              button_entity: "{{ matching_button_entity }}"
              button_event_data: "{{ trigger.event.data }}"
              time_since_last_press: "{{ time_diff | round(3) }}"
              timestamp: "{{ current_timestamp }}"
              light_entities: "{{ light_entities }}"

      # Restore brightness for each light to original values
      - repeat:
          for_each: "{{ light_entities }}"
          sequence:
            - variables:
                light_entity: "{{ repeat.item }}"
                target_brightness_value: "{{ stored_light_brightness.get(light_entity) }}"

            - if:
                - condition: template
                  value_template: "{{ target_brightness_value is not none }}"
              then:
                # Turn on with brightness
                - if:
                    - condition: template
                      value_template: "{{ enable_logging }}"
                  then:
                    - service: logbook.log
                      data:
                        name: "Lutron double tap light set"
                        message: "Lutron double tap setting {{ light_entity }} to brightness {{ target_brightness_value }}"

                - if:
                    - condition: template
                      value_template: "{{ target_brightness_value | int > 0 }}"
                  then:
                    - service: light.turn_on
                      target:
                        entity_id: "{{ light_entity }}"
                      data: >
                        {% set data = {"brightness": target_brightness_value | int} %}
                        {{ data }}
                  # Turn off
                  else:
                    - service: light.turn_off
                      target:
                        entity_id: "{{ light_entity }}"

      # Trigger actions (only if provided)
      - alias: "Run the actions"
        choose: []
        default: !input triggered_action

    else:
      # Log single tap
      - if:
          - condition: template
            value_template: "{{ enable_logging }}"
        then:
          - service: logbook.log
            data:
              name: "Single Tap"
              message: "Single tap detected for {{ matching_button_entity }}"
      # Update stored data with timing and current light states
      - service: input_text.set_value
        target:
          entity_id: "{{ storage_helper }}"
        data:
          value: "{{ dict(stored_data, last_press=current_timestamp, lights=current_light_brightness) | to_json }}"
